{"version":3,"sources":["jquery.validate.unobtrusive.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"jquery-validate-unobtrusive.js","sourcesContent":["/*!\r\n** Unobtrusive validation support library for jQuery and jQuery Validate\r\n** Copyright (C) Microsoft Corporation. All rights reserved.\r\n*/\r\n\r\n/*jslint white: true, browser: true, onevar: true, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, strict: false */\r\n/*global document: false, jQuery: false */\r\n\r\n(function ($) {\r\n    var $jQval = $.validator,\r\n        adapters,\r\n        data_validation = \"unobtrusiveValidation\";\r\n\r\n    function setValidationValues(options, ruleName, value) {\r\n        options.rules[ruleName] = value;\r\n        if (options.message) {\r\n            options.messages[ruleName] = options.message;\r\n        }\r\n    }\r\n\r\n    function splitAndTrim(value) {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\").split(/\\s*,\\s*/g);\r\n    }\r\n\r\n    function escapeAttributeValue(value) {\r\n        // As mentioned on http://api.jquery.com/category/selectors/\r\n        return value.replace(/([!\"#$%&'()*+,./:;<=>?@\\[\\\\\\]^`{|}~])/g, \"\\\\$1\");\r\n    }\r\n\r\n    function getModelPrefix(fieldName) {\r\n        return fieldName.substr(0, fieldName.lastIndexOf(\".\") + 1);\r\n    }\r\n\r\n    function appendModelPrefix(value, prefix) {\r\n        if (value.indexOf(\"*.\") === 0) {\r\n            value = value.replace(\"*.\", prefix);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function onError(error, inputElement) {  // 'this' is the form element\r\n        var container = $(this).find(\"[data-valmsg-for='\" + escapeAttributeValue(inputElement[0].name) + \"']\"),\r\n            replaceAttrValue = container.attr(\"data-valmsg-replace\"),\r\n            replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) !== false : null;\r\n\r\n        container.removeClass(\"field-validation-valid\").addClass(\"field-validation-error\");\r\n        error.data(\"unobtrusiveContainer\", container);\r\n\r\n        if (replace) {\r\n            container.empty();\r\n            error.removeClass(\"input-validation-error\").appendTo(container);\r\n        }\r\n        else {\r\n            error.hide();\r\n        }\r\n    }\r\n\r\n    function onErrors(event, validator) {  // 'this' is the form element\r\n        var container = $(this).find(\"[data-valmsg-summary=true]\"),\r\n            list = container.find(\"ul\");\r\n\r\n        if (list && list.length && validator.errorList.length) {\r\n            list.empty();\r\n            container.addClass(\"validation-summary-errors\").removeClass(\"validation-summary-valid\");\r\n\r\n            $.each(validator.errorList, function () {\r\n                $(\"<li />\").html(this.message).appendTo(list);\r\n            });\r\n        }\r\n    }\r\n\r\n    function onSuccess(error) {  // 'this' is the form element\r\n        var container = error.data(\"unobtrusiveContainer\");\r\n\r\n        if (container) {\r\n            var replaceAttrValue = container.attr(\"data-valmsg-replace\"),\r\n                replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) : null;\r\n\r\n            container.addClass(\"field-validation-valid\").removeClass(\"field-validation-error\");\r\n            error.removeData(\"unobtrusiveContainer\");\r\n\r\n            if (replace) {\r\n                container.empty();\r\n            }\r\n        }\r\n    }\r\n\r\n    function onReset(event) {  // 'this' is the form element\r\n        var $form = $(this),\r\n            key = '__jquery_unobtrusive_validation_form_reset';\r\n        if ($form.data(key)) {\r\n            return;\r\n        }\r\n        // Set a flag that indicates we're currently resetting the form.\r\n        $form.data(key, true);\r\n        try {\r\n            $form.data(\"validator\").resetForm();\r\n        } finally {\r\n            $form.removeData(key);\r\n        }\r\n\r\n        $form.find(\".validation-summary-errors\")\r\n            .addClass(\"validation-summary-valid\")\r\n            .removeClass(\"validation-summary-errors\");\r\n        $form.find(\".field-validation-error\")\r\n            .addClass(\"field-validation-valid\")\r\n            .removeClass(\"field-validation-error\")\r\n            .removeData(\"unobtrusiveContainer\")\r\n            .find(\">*\")  // If we were using valmsg-replace, get the underlying error\r\n                .removeData(\"unobtrusiveContainer\");\r\n    }\r\n\r\n    function validationInfo(form) {\r\n        var $form = $(form),\r\n            result = $form.data(data_validation),\r\n            onResetProxy = $.proxy(onReset, form),\r\n            defaultOptions = $jQval.unobtrusive.options || {},\r\n            execInContext = function (name, args) {\r\n                var func = defaultOptions[name];\r\n                func && $.isFunction(func) && func.apply(form, args);\r\n            }\r\n\r\n        if (!result) {\r\n            result = {\r\n                options: {  // options structure passed to jQuery Validate's validate() method\r\n                    errorClass: defaultOptions.errorClass || \"input-validation-error\",\r\n                    errorElement: defaultOptions.errorElement || \"span\",\r\n                    errorPlacement: function () {\r\n                        onError.apply(form, arguments);\r\n                        execInContext(\"errorPlacement\", arguments);\r\n                    },\r\n                    invalidHandler: function () {\r\n                        onErrors.apply(form, arguments);\r\n                        execInContext(\"invalidHandler\", arguments);\r\n                    },\r\n                    messages: {},\r\n                    rules: {},\r\n                    success: function () {\r\n                        onSuccess.apply(form, arguments);\r\n                        execInContext(\"success\", arguments);\r\n                    }\r\n                },\r\n                attachValidation: function () {\r\n                    $form\r\n                        .off(\"reset.\" + data_validation, onResetProxy)\r\n                        .on(\"reset.\" + data_validation, onResetProxy)\r\n                        .validate(this.options);\r\n                },\r\n                validate: function () {  // a validation function that is called by unobtrusive Ajax\r\n                    $form.validate();\r\n                    return $form.valid();\r\n                }\r\n            };\r\n            $form.data(data_validation, result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    $jQval.unobtrusive = {\r\n        adapters: [],\r\n\r\n        parseElement: function (element, skipAttach) {\r\n            /// <summary>\r\n            /// Parses a single HTML element for unobtrusive validation attributes.\r\n            /// </summary>\r\n            /// <param name=\"element\" domElement=\"true\">The HTML element to be parsed.</param>\r\n            /// <param name=\"skipAttach\" type=\"Boolean\">[Optional] true to skip attaching the\r\n            /// validation to the form. If parsing just this single element, you should specify true.\r\n            /// If parsing several elements, you should specify false, and manually attach the validation\r\n            /// to the form when you are finished. The default is false.</param>\r\n            var $element = $(element),\r\n                form = $element.parents(\"form\")[0],\r\n                valInfo, rules, messages;\r\n\r\n            if (!form) {  // Cannot do client-side validation without a form\r\n                return;\r\n            }\r\n\r\n            valInfo = validationInfo(form);\r\n            valInfo.options.rules[element.name] = rules = {};\r\n            valInfo.options.messages[element.name] = messages = {};\r\n\r\n            $.each(this.adapters, function () {\r\n                var prefix = \"data-val-\" + this.name,\r\n                    message = $element.attr(prefix),\r\n                    paramValues = {};\r\n\r\n                if (message !== undefined) {  // Compare against undefined, because an empty message is legal (and falsy)\r\n                    prefix += \"-\";\r\n\r\n                    $.each(this.params, function () {\r\n                        paramValues[this] = $element.attr(prefix + this);\r\n                    });\r\n\r\n                    this.adapt({\r\n                        element: element,\r\n                        form: form,\r\n                        message: message,\r\n                        params: paramValues,\r\n                        rules: rules,\r\n                        messages: messages\r\n                    });\r\n                }\r\n            });\r\n\r\n            $.extend(rules, { \"__dummy__\": true });\r\n\r\n            if (!skipAttach) {\r\n                valInfo.attachValidation();\r\n            }\r\n        },\r\n\r\n        parse: function (selector) {\r\n            /// <summary>\r\n            /// Parses all the HTML elements in the specified selector. It looks for input elements decorated\r\n            /// with the [data-val=true] attribute value and enables validation according to the data-val-*\r\n            /// attribute values.\r\n            /// </summary>\r\n            /// <param name=\"selector\" type=\"String\">Any valid jQuery selector.</param>\r\n\r\n            // $forms includes all forms in selector's DOM hierarchy (parent, children and self) that have at least one\r\n            // element with data-val=true\r\n            var $selector = $(selector),\r\n                $forms = $selector.parents()\r\n                                  .addBack()\r\n                                  .filter(\"form\")\r\n                                  .add($selector.find(\"form\"))\r\n                                  .has(\"[data-val=true]\");\r\n\r\n            $selector.find(\"[data-val=true]\").each(function () {\r\n                $jQval.unobtrusive.parseElement(this, true);\r\n            });\r\n\r\n            $forms.each(function () {\r\n                var info = validationInfo(this);\r\n                if (info) {\r\n                    info.attachValidation();\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    adapters = $jQval.unobtrusive.adapters;\r\n\r\n    adapters.add = function (adapterName, params, fn) {\r\n        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation.</summary>\r\n        /// <param name=\"adapterName\" type=\"String\">The name of the adapter to be added. This matches the name used\r\n        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>\r\n        /// <param name=\"params\" type=\"Array\" optional=\"true\">[Optional] An array of parameter names (strings) that will\r\n        /// be extracted from the data-val-nnnn-mmmm HTML attributes (where nnnn is the adapter name, and\r\n        /// mmmm is the parameter name).</param>\r\n        /// <param name=\"fn\" type=\"Function\">The function to call, which adapts the values from the HTML\r\n        /// attributes into jQuery Validate rules and/or messages.</param>\r\n        /// <returns type=\"jQuery.validator.unobtrusive.adapters\" />\r\n        if (!fn) {  // Called with no params, just a function\r\n            fn = params;\r\n            params = [];\r\n        }\r\n        this.push({ name: adapterName, params: params, adapt: fn });\r\n        return this;\r\n    };\r\n\r\n    adapters.addBool = function (adapterName, ruleName) {\r\n        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where\r\n        /// the jQuery Validate validation rule has no parameter values.</summary>\r\n        /// <param name=\"adapterName\" type=\"String\">The name of the adapter to be added. This matches the name used\r\n        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>\r\n        /// <param name=\"ruleName\" type=\"String\" optional=\"true\">[Optional] The name of the jQuery Validate rule. If not provided, the value\r\n        /// of adapterName will be used instead.</param>\r\n        /// <returns type=\"jQuery.validator.unobtrusive.adapters\" />\r\n        return this.add(adapterName, function (options) {\r\n            setValidationValues(options, ruleName || adapterName, true);\r\n        });\r\n    };\r\n\r\n    adapters.addMinMax = function (adapterName, minRuleName, maxRuleName, minMaxRuleName, minAttribute, maxAttribute) {\r\n        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where\r\n        /// the jQuery Validate validation has three potential rules (one for min-only, one for max-only, and\r\n        /// one for min-and-max). The HTML parameters are expected to be named -min and -max.</summary>\r\n        /// <param name=\"adapterName\" type=\"String\">The name of the adapter to be added. This matches the name used\r\n        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>\r\n        /// <param name=\"minRuleName\" type=\"String\">The name of the jQuery Validate rule to be used when you only\r\n        /// have a minimum value.</param>\r\n        /// <param name=\"maxRuleName\" type=\"String\">The name of the jQuery Validate rule to be used when you only\r\n        /// have a maximum value.</param>\r\n        /// <param name=\"minMaxRuleName\" type=\"String\">The name of the jQuery Validate rule to be used when you\r\n        /// have both a minimum and maximum value.</param>\r\n        /// <param name=\"minAttribute\" type=\"String\" optional=\"true\">[Optional] The name of the HTML attribute that\r\n        /// contains the minimum value. The default is \"min\".</param>\r\n        /// <param name=\"maxAttribute\" type=\"String\" optional=\"true\">[Optional] The name of the HTML attribute that\r\n        /// contains the maximum value. The default is \"max\".</param>\r\n        /// <returns type=\"jQuery.validator.unobtrusive.adapters\" />\r\n        return this.add(adapterName, [minAttribute || \"min\", maxAttribute || \"max\"], function (options) {\r\n            var min = options.params.min,\r\n                max = options.params.max;\r\n\r\n            if (min && max) {\r\n                setValidationValues(options, minMaxRuleName, [min, max]);\r\n            }\r\n            else if (min) {\r\n                setValidationValues(options, minRuleName, min);\r\n            }\r\n            else if (max) {\r\n                setValidationValues(options, maxRuleName, max);\r\n            }\r\n        });\r\n    };\r\n\r\n    adapters.addSingleVal = function (adapterName, attribute, ruleName) {\r\n        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where\r\n        /// the jQuery Validate validation rule has a single value.</summary>\r\n        /// <param name=\"adapterName\" type=\"String\">The name of the adapter to be added. This matches the name used\r\n        /// in the data-val-nnnn HTML attribute(where nnnn is the adapter name).</param>\r\n        /// <param name=\"attribute\" type=\"String\">[Optional] The name of the HTML attribute that contains the value.\r\n        /// The default is \"val\".</param>\r\n        /// <param name=\"ruleName\" type=\"String\" optional=\"true\">[Optional] The name of the jQuery Validate rule. If not provided, the value\r\n        /// of adapterName will be used instead.</param>\r\n        /// <returns type=\"jQuery.validator.unobtrusive.adapters\" />\r\n        return this.add(adapterName, [attribute || \"val\"], function (options) {\r\n            setValidationValues(options, ruleName || adapterName, options.params[attribute]);\r\n        });\r\n    };\r\n\r\n    $jQval.addMethod(\"__dummy__\", function (value, element, params) {\r\n        return true;\r\n    });\r\n\r\n    $jQval.addMethod(\"regex\", function (value, element, params) {\r\n        var match;\r\n        if (this.optional(element)) {\r\n            return true;\r\n        }\r\n\r\n        match = new RegExp(params).exec(value);\r\n        return (match && (match.index === 0) && (match[0].length === value.length));\r\n    });\r\n\r\n    $jQval.addMethod(\"nonalphamin\", function (value, element, nonalphamin) {\r\n        var match;\r\n        if (nonalphamin) {\r\n            match = value.match(/\\W/g);\r\n            match = match && match.length >= nonalphamin;\r\n        }\r\n        return match;\r\n    });\r\n\r\n    if ($jQval.methods.extension) {\r\n        adapters.addSingleVal(\"accept\", \"mimtype\");\r\n        adapters.addSingleVal(\"extension\", \"extension\");\r\n    } else {\r\n        // for backward compatibility, when the 'extension' validation method does not exist, such as with versions\r\n        // of JQuery Validation plugin prior to 1.10, we should use the 'accept' method for\r\n        // validating the extension, and ignore mime-type validations as they are not supported.\r\n        adapters.addSingleVal(\"extension\", \"extension\", \"accept\");\r\n    }\r\n\r\n    adapters.addSingleVal(\"regex\", \"pattern\");\r\n    adapters.addBool(\"creditcard\").addBool(\"date\").addBool(\"digits\").addBool(\"email\").addBool(\"number\").addBool(\"url\");\r\n    adapters.addMinMax(\"length\", \"minlength\", \"maxlength\", \"rangelength\").addMinMax(\"range\", \"min\", \"max\", \"range\");\r\n    adapters.addMinMax(\"minlength\", \"minlength\").addMinMax(\"maxlength\", \"minlength\", \"maxlength\");\r\n    adapters.add(\"equalto\", [\"other\"], function (options) {\r\n        var prefix = getModelPrefix(options.element.name),\r\n            other = options.params.other,\r\n            fullOtherName = appendModelPrefix(other, prefix),\r\n            element = $(options.form).find(\":input\").filter(\"[name='\" + escapeAttributeValue(fullOtherName) + \"']\")[0];\r\n\r\n        setValidationValues(options, \"equalTo\", element);\r\n    });\r\n    adapters.add(\"required\", function (options) {\r\n        // jQuery Validate equates \"required\" with \"mandatory\" for checkbox elements\r\n        if (options.element.tagName.toUpperCase() !== \"INPUT\" || options.element.type.toUpperCase() !== \"CHECKBOX\") {\r\n            setValidationValues(options, \"required\", true);\r\n        }\r\n    });\r\n    adapters.add(\"remote\", [\"url\", \"type\", \"additionalfields\"], function (options) {\r\n        var value = {\r\n            url: options.params.url,\r\n            type: options.params.type || \"GET\",\r\n            data: {}\r\n        },\r\n            prefix = getModelPrefix(options.element.name);\r\n\r\n        $.each(splitAndTrim(options.params.additionalfields || options.element.name), function (i, fieldName) {\r\n            var paramName = appendModelPrefix(fieldName, prefix);\r\n            value.data[paramName] = function () {\r\n                var field = $(options.form).find(\":input\").filter(\"[name='\" + escapeAttributeValue(paramName) + \"']\");\r\n                // For checkboxes and radio buttons, only pick up values from checked fields.\r\n                if (field.is(\":checkbox\")) {\r\n                    return field.filter(\":checked\").val() || field.filter(\":hidden\").val() || '';\r\n                }\r\n                else if (field.is(\":radio\")) {\r\n                    return field.filter(\":checked\").val() || '';\r\n                }\r\n                return field.val();\r\n            };\r\n        });\r\n\r\n        setValidationValues(options, \"remote\", value);\r\n    });\r\n    adapters.add(\"password\", [\"min\", \"nonalphamin\", \"regex\"], function (options) {\r\n        if (options.params.min) {\r\n            setValidationValues(options, \"minlength\", options.params.min);\r\n        }\r\n        if (options.params.nonalphamin) {\r\n            setValidationValues(options, \"nonalphamin\", options.params.nonalphamin);\r\n        }\r\n        if (options.params.regex) {\r\n            setValidationValues(options, \"regex\", options.params.regex);\r\n        }\r\n    });\r\n\r\n    $(function () {\r\n        $jQval.unobtrusive.parse(document);\r\n    });\r\n}(jQuery));"]}